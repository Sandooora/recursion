def generatePathsTailRecursion(n, current_path=[], all_paths=[]):
    # Базові випадки
    if n == 0:
        all_paths.append(current_path)
        return all_paths
    if n < 0:
        return all_paths

    # Рекурсивні виклики для 1 кроку і 2 кроків
    generatePathsTailRecursion(n - 1, current_path + [1], all_paths)
    generatePathsTailRecursion(n - 2, current_path + [2], all_paths)

    return all_paths

# Введення значення n з перевіркою на обмеження
while True:
    n = int(input("Введіть кількість сходів (n): "))
    if 1 <= n <= 45:
        break
    else:
        print("Число повинно бути в межах від 1 до 45. Спробуйте ще раз.")

# Генерація всіх можливих шляхів
paths = generatePathsTailRecursion(n)

# Виведення результату
print(f"\nКількість унікальних способів піднятися на вершину: {len(paths)}")

# Пояснення рішення
print("\nПояснення:")
print(f"There are {len(paths)} ways to climb to the top.")
for path in paths:
    print(" + ".join([f"{step} step" for step in path]))
